{"componentChunkName":"component---src-templates-playground-tsx","path":"/0.6/playground/buffer-mesh-instance","result":{"pageContext":{"node":{"internal":{"content":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define([\"@oasis-engine/controls\", \"oasis-engine\"], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(require(\"@oasis-engine/controls\"), require(\"oasis-engine\"));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(global[\"@oasisEngine/controls\"], global.oasisEngine);\n    global.index = mod.exports;\n  }\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : this, function (_controls, _oasisEngine) {\n  \"use strict\";\n\n  /**\n   * @title Buffer Mesh Instance\n   * @category Mesh\n   */\n  // Create engine.\n  var engine = new _oasisEngine.WebGLEngine(\"canvas\");\n  engine.canvas.resizeByClientSize(); // Get scene and root entity.\n\n  var scene = engine.sceneManager.activeScene;\n  var rootEntity = scene.createRootEntity(\"Root\"); // Init instance shader.\n\n  var shader = initCustomShader(); // Create camera.\n\n  var cameraEntity = rootEntity.createChild(\"Camera\");\n  var camera = cameraEntity.addComponent(_oasisEngine.Camera);\n  cameraEntity.addComponent(_controls.OrbitControl);\n  cameraEntity.transform.setPosition(0, 10, 160);\n  cameraEntity.transform.lookAt(new _oasisEngine.Vector3(0, 0, 0));\n  camera.farClipPlane = 300; // Create Instance Cube.\n\n  var cubeEntity = rootEntity.createChild(\"Cube\");\n  var cubeRenderer = cubeEntity.addComponent(_oasisEngine.MeshRenderer);\n  var material = new _oasisEngine.Material(engine, shader);\n  cubeEntity.transform.rotate(0, 60, 0);\n  cubeRenderer.mesh = createCustomMesh(engine, 1.0); // Use `createCustomMesh()` to create custom instance cube mesh.\n\n  cubeRenderer.setMaterial(material); // Run engine.\n\n  engine.run();\n  /**\n   * Create cube geometry with custom BufferGeometry.\n   * @param engine - Engine\n   * @param size - Cube size\n   * @returns Cube mesh\n   */\n\n  function createCustomMesh(engine, size) {\n    var geometry = new _oasisEngine.BufferMesh(engine, \"CustomCubeGeometry\"); // Create vertices data.\n    // prettier-ignore\n\n    var vertices = new Float32Array([// Up\n    -size, size, -size, 0, 1, 0, size, size, -size, 0, 1, 0, size, size, size, 0, 1, 0, -size, size, size, 0, 1, 0, // Down\n    -size, -size, -size, 0, -1, 0, size, -size, -size, 0, -1, 0, size, -size, size, 0, -1, 0, -size, -size, size, 0, -1, 0, // Left\n    -size, size, -size, -1, 0, 0, -size, size, size, -1, 0, 0, -size, -size, size, -1, 0, 0, -size, -size, -size, -1, 0, 0, // Right\n    size, size, -size, 1, 0, 0, size, size, size, 1, 0, 0, size, -size, size, 1, 0, 0, size, -size, -size, 1, 0, 0, // Front\n    -size, size, size, 0, 0, 1, size, size, size, 0, 0, 1, size, -size, size, 0, 0, 1, -size, -size, size, 0, 0, 1, // Back\n    -size, size, -size, 0, 0, -1, size, size, -size, 0, 0, -1, size, -size, -size, 0, 0, -1, -size, -size, -size, 0, 0, -1]); // Create instance data.\n\n    var instanceCount = 4000;\n    var instanceStride = 6;\n    var instanceData = new Float32Array(instanceCount * instanceStride);\n\n    for (var i = 0; i < instanceCount; i++) {\n      var offset = i * instanceStride; // instance offset\n\n      instanceData[offset] = (Math.random() - 0.5) * 60;\n      instanceData[offset + 1] = (Math.random() - 0.5) * 60;\n      instanceData[offset + 2] = (Math.random() - 0.5) * 60; // instance color\n\n      instanceData[offset + 3] = Math.random();\n      instanceData[offset + 4] = Math.random();\n      instanceData[offset + 5] = Math.random();\n    } // Create indices data.\n    // prettier-ignore\n\n\n    var indices = new Uint16Array([// Up\n    0, 2, 1, 2, 0, 3, // Down\n    4, 6, 7, 6, 4, 5, // Left\n    8, 10, 9, 10, 8, 11, // Right\n    12, 14, 15, 14, 12, 13, // Front\n    16, 18, 17, 18, 16, 19, // Back\n    20, 22, 23, 22, 20, 21]); // Create gpu vertex buffer and index buffer.\n\n    var vertexBuffer = new _oasisEngine.Buffer(engine, _oasisEngine.BufferBindFlag.VertexBuffer, vertices, _oasisEngine.BufferUsage.Static);\n    var instanceVertexBuffer = new _oasisEngine.Buffer(engine, _oasisEngine.BufferBindFlag.VertexBuffer, instanceData, _oasisEngine.BufferUsage.Static);\n    var indexBuffer = new _oasisEngine.Buffer(engine, _oasisEngine.BufferBindFlag.IndexBuffer, indices, _oasisEngine.BufferUsage.Static); // Bind buffer\n\n    geometry.setVertexBufferBinding(vertexBuffer, 24, 0);\n    geometry.setVertexBufferBinding(instanceVertexBuffer, 24, 1);\n    geometry.setIndexBufferBinding(indexBuffer, _oasisEngine.IndexFormat.UInt16); // Add vertexElements\n\n    geometry.setVertexElements([new _oasisEngine.VertexElement(\"POSITION\", 0, _oasisEngine.VertexElementFormat.Vector3, 0, 0), // Bind to VertexBuffer 0\n    new _oasisEngine.VertexElement(\"NORMAL\", 12, _oasisEngine.VertexElementFormat.Vector3, 0, 0), // Bind to VertexBuffer 0\n    new _oasisEngine.VertexElement(\"INSTANCE_OFFSET\", 0, _oasisEngine.VertexElementFormat.Vector3, 1, 1), // Bind instance offset to VertexBuffer 1, and enable instance by set instanceStepRate with 1\n    new _oasisEngine.VertexElement(\"INSTANCE_COLOR\", 12, _oasisEngine.VertexElementFormat.Vector3, 1, 1) // Bind instance color to VertexBuffer 1, and enable instance by set instanceStepRate with 1\n    ]); // Add one sub geometry.\n\n    geometry.addSubMesh(0, indices.length);\n    geometry.instanceCount = instanceCount;\n    return geometry;\n  }\n  /**\n   * Create custom instance shader.\n   */\n\n\n  function initCustomShader() {\n    var shader = _oasisEngine.Shader.create(\"CustomShader\", \"uniform mat4 u_MVPMat;\\n      attribute vec4 POSITION;\\n      attribute vec3 INSTANCE_OFFSET;\\n      attribute vec3 INSTANCE_COLOR;\\n      \\n      uniform mat4 u_MVMat;\\n      \\n      varying vec3 v_position;\\n      varying vec3 v_color;\\n      \\n      void main() {\\n        vec4 position = POSITION;\\n        position.xyz += INSTANCE_OFFSET;\\n        gl_Position = u_MVPMat * position;\\n\\n        v_color = INSTANCE_COLOR;\\n      }\", \"\\n      varying vec3 v_color;\\n      uniform vec4 u_color;\\n      \\n      void main() {\\n        vec4 color = vec4(v_color,1.0);\\n        gl_FragColor = color;\\n      }\\n      \");\n\n    return shader;\n  }\n});"},"name":"buffer-mesh-instance","id":"f87a7ccb-1616-564c-986f-7d08693a5dcf"}}},"staticQueryHashes":[]}